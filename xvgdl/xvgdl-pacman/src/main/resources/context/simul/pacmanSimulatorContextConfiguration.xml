<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!-- Definition of pacman game -->

<gameDefinition>

    <!-- Renderer configuration not needed for simulation -->
    <!-- Timeout configuration in milliseconds. Generated randomly -->

    <!-- Map Definition. Generated randomly -->
    <map type="2D" sizeX="25" sizeY="30" toroidal="false"
        generator="es.jor.phd.xvgdl.model.map.RandomLocationGameMapGenerator">
    </map>

    <!-- Players Definition -->
    <players number="1" maxNumber="1" minNumber="1">
        <player name="pacman" score="0" lives="3" livePercentage="100" ai="es.jor.phd.xvgdl.model.object.ai.PlayerChaseNearestItemAI"/>
    </players>
    <!-- Defining the Objects present in the game (NPCs, Obsctacles, projectiles,
        structures, collectibles, etc... -->
    <objects>
        <object name="wall" type="wall" dynamic="false" volatile="false" sizeX="1" sizeY="1" instances="10" />
        <object name="ghost" type="enemy" dynamic="true" volatile="true" size="1,1" instances="4" ai="es.jor.phd.xvgdl.model.object.ai.PlayerChaserAI" />
        <object name="smallDot" type="item" dynamic="true" volatile="true" size="1,1" instances="2" />
        <object name="bigDot" type="item" dynamic="true" volatile="true" size="1,1" instances="2" />
        <object name="cherry" type="item" dynamic="true" volatile="true" size="1,1" instances="1" />
    </objects>

    <!-- Defining Game physics. Movements and collisions Define set of possible
        physics action: gravitational pull, friction, repulsion forces, bouncing
        effects, stickiness, etc Define the -->
    <physics>
    </physics>

    <!-- Defining game events. Events sent from the player via input devices,
        timed or random events, and object collision triggered events that affect
        the game. May be as an example some item appears randomly. It can use a timer
        (not before X milliseconds) or a random value to be executed -->
    <events>
        <event type="engine" className="es.jor.phd.xvgdl.model.event.SpawnItemEvent"
            objectName="cherry" timer="5000" />
        <event type="engine" className="es.jor.phd.xvgdl.model.event.SpawnItemEvent"
            objectName="ghost" timer="50000" />
    </events>

    <!-- Defining rules. Events consecuences -->
    <rules>
    	<!-- Rule for object collision with wall -->
<!--     	<rule name="wallCollision" type="collision"> -->
<!--             <ruleAction objectName="pacman" result="cantMove"/> -->
<!--             <ruleAction objectName="wall" result="cantMove"/> -->
<!--         </rule> -->

        <!-- Rule for pacman eating small dots Esto tiene buena pinta. Se
            cargan las reglas, tienen un tipo (collision/proximidad/distancia) y un valor.
            Cada regla tiene un array de elementos por nombre de objecto Se cogerá de
            cada regla la lista de elementos de cada cosa. En función del tipo de regla,
            se comprueba si las NxM combinaciones se cumple la regla y en ese caso, A
            cada objeto se le aplica el resultado. -->
        <rule name="eatSmallDot" type="collision">
            <ruleAction objectName="pacman" result="scoreUp"
                value="100" />
            <ruleAction objectName="smallDot" result="disappear" />
        </rule>
        <rule name="eatBigDot" type="collision">
            <ruleAction objectName="pacman" result="scoreUp"
                value="300" />
            <ruleAction objectName="bigDot" result="disappear" />
        </rule>
        <rule name="eatCherry" type="collision">
            <ruleAction objectName="pacman" result="scoreUp"
                value="500" />
            <ruleAction objectName="cherry" result="disappear" />
        </rule>
        <rule name="ghostCatchPacman" type="collision">
            <ruleAction objectName="pacman" result="teletransport" />
            <ruleAction objectName="ghost" result="" value=""/>
        </rule>
        <rule name="ghostCatchPacmanLivesDown" type="collision">
            <ruleAction objectName="pacman" result="livesDown" />
            <ruleAction objectName="ghost" result="" value=""/>
        </rule>

    </rules>
    <!-- Game End Conditions -->
    <!--  To be generated automatically by the Pacman simulator context generator. -->
    <endConditions>
        <endCondition checkerClass="es.jor.phd.xvgdl.model.endcondition.LivesZeroGameEndCondition"/>
        <endCondition checkerClass="es.jor.phd.xvgdl.model.endcondition.NoObjectsPresentGameEndCondition" winningCondition="true" objectNames="smallDot,bigDot"/>
    </endConditions>


    <!-- Game Objectives -->
    <!--
    	Weight should be a double value, and can be even negative to penalize a concrete property.
    	Default weight would be 1.0d if no specific value is set
    	Some objectives can have a score to calculate the objective final score in the fitness function.
    	Default score will be 0 for all objectives if no specific value is set
    -->
    <objectives>
        <objective objectiveCheckerClass="es.jor.phd.xvgdl.model.objectives.MaximizeScoreObjective" weight="1.0"/>
        <objective objectiveCheckerClass="es.jor.phd.xvgdl.model.objectives.MaximizeTurnsObjective" weight="0.5"/>
        <objective objectiveCheckerClass="es.jor.phd.xvgdl.model.objectives.MaximizeTimeObjective" weight="0.75"/>
        <objective objectiveCheckerClass="es.jor.phd.xvgdl.model.objectives.PlayerWinsObjective" score="200" weight="1.0"/>
        <objective objectiveCheckerClass="es.jor.phd.xvgdl.model.objectives.DifferenceBetweenInitialAndFinalLives" score="200" weight="1.0"/>
    </objectives>
</gameDefinition>

